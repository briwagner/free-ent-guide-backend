// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package modelstore

import (
	"context"
	"database/sql"
	"encoding/json"
)

const userAppendZip = `-- name: UserAppendZip :exec
UPDATE users
  SET data = JSON_ARRAY_APPEND(data, '$.zips', ?)
  WHERE email = ?
`

type UserAppendZipParams struct {
	JSONARRAYAPPEND interface{}
	Email           string
}

func (q *Queries) UserAppendZip(ctx context.Context, arg UserAppendZipParams) error {
	_, err := q.db.ExecContext(ctx, userAppendZip, arg.JSONARRAYAPPEND, arg.Email)
	return err
}

const userCheckPassword = `-- name: UserCheckPassword :one
SELECT id, email, password_hash, status
  FROM users
  WHERE email = ?
  LIMIT 1
`

type UserCheckPasswordRow struct {
	ID           int64
	Email        string
	PasswordHash string
	Status       sql.NullBool
}

func (q *Queries) UserCheckPassword(ctx context.Context, email string) (UserCheckPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, userCheckPassword, email)
	var i UserCheckPasswordRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Status,
	)
	return i, err
}

const userCreate = `-- name: UserCreate :execlastid
INSERT INTO users
  (email, password_hash, data, created_at)
  VALUES
  (?, ?, ?, ?)
`

type UserCreateParams struct {
	Email        string
	PasswordHash string
	Data         json.RawMessage
	CreatedAt    sql.NullTime
}

func (q *Queries) UserCreate(ctx context.Context, arg UserCreateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, userCreate,
		arg.Email,
		arg.PasswordHash,
		arg.Data,
		arg.CreatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const userExtractZips = `-- name: UserExtractZips :one
SELECT JSON_EXTRACT(data, '$.zips')
  FROM users
  WHERE email = ?
`

func (q *Queries) UserExtractZips(ctx context.Context, email string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, userExtractZips, email)
	var json_extract interface{}
	err := row.Scan(&json_extract)
	return json_extract, err
}

const userFindByEmail = `-- name: UserFindByEmail :one
SELECT id, email, JSON_EXTRACT(data, '$.zips') AS zips, created_at, status
  FROM users
  WHERE email = ?
  LIMIT 1
`

type UserFindByEmailRow struct {
	ID        int64
	Email     string
	Zips      interface{}
	CreatedAt sql.NullTime
	Status    sql.NullBool
}

func (q *Queries) UserFindByEmail(ctx context.Context, email string) (UserFindByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, userFindByEmail, email)
	var i UserFindByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Zips,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const userSetZips = `-- name: UserSetZips :exec
UPDATE users
  SET data = JSON_SET(data, '$.zips', CAST(? AS JSON))
  WHERE email = ?
`

type UserSetZipsParams struct {
	Column1 json.RawMessage
	Email   string
}

func (q *Queries) UserSetZips(ctx context.Context, arg UserSetZipsParams) error {
	_, err := q.db.ExecContext(ctx, userSetZips, arg.Column1, arg.Email)
	return err
}

const usersDelete = `-- name: UsersDelete :exec
DELETE FROM users
`

func (q *Queries) UsersDelete(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, usersDelete)
	return err
}
